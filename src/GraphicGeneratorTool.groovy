import commands.VisualizerCommand
import org.semanticweb.HermiT.Reasoner;
import org.semanticweb.elk.owlapi.ElkReasonerFactory
import org.semanticweb.owlapi.apibinding.OWLManager
import org.semanticweb.owlapi.io.FileDocumentSource
import org.semanticweb.owlapi.model.IRI
import org.semanticweb.owlapi.model.MissingImportHandlingStrategy;
import org.semanticweb.owlapi.model.OWLOntology
import org.semanticweb.owlapi.model.OWLOntologyLoaderConfiguration
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.reasoner.OWLReasoner;
import org.semanticweb.owlapi.reasoner.OWLReasonerFactory
import view.FormatterType

import java.util.regex.Matcher
import java.util.regex.Pattern;

/**
 * Main class
 * @author Miguel Angel Rodríguez García
 * @version 1.0
 */


public class GraphicGeneratorTool {
    public static final String MANUAL="MAN GRAPHGENERATORTOOL";
    public static final String ELK_REASONER="ELK";
    public static final String HERMIT_REASONER="HERMIT";

    /**
     * Constructor
     */
    public GraphicGeneratorTool(){

    }

    public static void runGraphGenerator(OWLOntology ontology, String outputPath,OWLReasoner reasoner,
                                         FormatterType formatterType,String[] objectProperties){
        VisualizerCommand command = new VisualizerCommand(reasoner,ontology,formatterType,outputPath,objectProperties);
        command.executeCommand();
    }

    public static OWLOntology loadOntology(String pathOntology){
        OWLOntology ontology = null;
        if((pathOntology!=null)&&(!pathOntology.isEmpty())){
            File owlFile = new File(pathOntology);
            if(owlFile.exists()) {
                OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
                OWLOntologyLoaderConfiguration config = new OWLOntologyLoaderConfiguration();
                config.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);
                FileDocumentSource fSource = new FileDocumentSource(owlFile);
                ontology = manager.loadOntologyFromOntologyDocument(fSource, config);
            }
        }
        return(ontology);
    }

    public static FormatterType getVisualizationFormatter(String typeFormatter){
        if((typeFormatter!=null)&&(!typeFormatter.isEmpty())){
            typeFormatter = typeFormatter.trim().toUpperCase();
            switch(typeFormatter){
                case "RDFXML": return(FormatterType.RDFXML_FORMATTER);
                case "GRAPHVIZ": return(FormatterType.GRAPHVIZ_FORMATTER);
                case "FLATFILE": return(FormatterType.FLATFILE_FORMATTER);
                case "GRAPHML": return(FormatterType.GRAPHML_FORMATTER);
                default: return(FormatterType.GRAPHVIZ_FORMATTER);
            }
        }
        return(null);
    }

    public static org.semanticweb.owlapi.reasoner.OWLReasoner getReasoner(String typeReasoner,OWLOntology ontology) {
        if ((typeReasoner != null) && (!typeReasoner.isEmpty())&&(ontology!=null)){
            typeReasoner = typeReasoner.trim().toUpperCase();
            switch(typeReasoner){
                case ELK_REASONER:
                    OWLReasonerFactory reasonerFactory = new ElkReasonerFactory();
                    return (reasonerFactory.createReasoner(ontology));
                case HERMIT_REASONER:
                    Reasoner hermit = new Reasoner(ontology);
                    return (hermit);
            }
        }
        return(null);
    }

    public static String getManual(){
        String info="These are the parameters that should be provided: \n";
        info+="args[0] This parameter should contain the ontology file or at least the path where the ontology is located. \n";
        info+="args[1] This parameter represents the output path where the files generated by the tool will be saved (Optional). \n";
        info+="args[2] The reasoner will be used (ELK,HERMIT). \n";
        info+="args[3] The different visualization formatted available (RDFXML, GRAPHVIZ[DEFAULT], FLATFILE,GRAPHML) (Optional). \n";
        info+="args[4] This parameter will contain the list of object properties that will be used to visualized the ontology. \n";
        info+="The object properties should be formatted as array, here you can see an example: [\"first_property\", \"second_property\", \"third_property\"]. (Optional) \n";
        return(info);
    }

    public static void main (String[] args){
        //args[0] The ontology file
        //args[1] Output path
        //args[2] Reasoners to use (ELK,Hermit)
        //args[3] Visualization formatter (RDFXML, GRAPHVIZ[DEFAULT], FLATFILE,GRAPHML)
        //args[4] List of properties to visualize should be on the format ["first_property", "second_property", "third_property"]
        if(args.length==5){
            OWLReasoner reasoner = null;
            OWLOntology ontology = null;
            String ontoFile = args[0];
            if((ontoFile!=null)&&(!ontoFile.isEmpty())){
                ontology = loadOntology(ontoFile);
                if(ontology!=null) {
                    String outputPath = args[1];
                    if ((outputPath == null) || (outputPath.isEmpty())) {
                        outputPath = System.getProperty("user.dir");
                    }

                    String sReasoner = args[2];
                    if ((sReasoner != null) && (!sReasoner.isEmpty())) {
                        reasoner = getReasoner(sReasoner, ontology);
                        if (reasoner != null) {

                            String sFormatter = args[3];
                            FormatterType formatterType;
                            if((sFormatter!=null)&&(!sFormatter.isEmpty())){
                                formatterType = getVisualizationFormatter(sFormatter);
                            }

                            Object objectProperties = args[4];
                            String[] properties;

                            if((objectProperties!=null)&&(!objectProperties.isEmpty())){
                                Pattern pattern = Pattern.compile("\\[(.*)\\]");
                                Matcher matcher = pattern.matcher(objectProperties);
                                if(matcher.find()&&(matcher.groupCount()>0)) {
                                    objectProperties = matcher.group(1);
                                    if(objectProperties.contains(",")){
                                        properties = objectProperties.split(",");
                                    }else{
                                        properties[0] = objectProperties;
                                    }
                                }
                            }
                            runGraphGenerator(ontology,outputPath,reasoner,formatterType,properties);

                        }else{
                            System.out.println("Error: Imposible to build the reasoner.");
                            System.exit(-1);
                        }
                    }
                }else{
                    System.out.println("Error: Impossible to load the ontology provided.");
                    System.exit(-1);
                }
            }
        }else{
            //print out the manual
            if(args.length==2) {
                String manual = args[0]+" "+args[1];
                if((manual!=null)&&(manual.toUpperCase().compareTo(MANUAL)==0)) {
                    System.out.println(getManual());
                    System.exit(0);
                }
            }
            System.out.println("Error providing the parameters");
            System.out.println(getManual());
        }
    }
}
